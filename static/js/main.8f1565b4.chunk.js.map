{"version":3,"sources":["languages.js","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/index.js","../../src/util.js","App.js","index.js"],"names":["languages","label","value","Symbol","iterator","asyncIterator","ReactTransliterate","Component","onBlur","disabled","lang","offsetX","offsetY","onChange","onKeyDown","containerClassName","containerStyles","activeItemStyles","maxOptions","rest","useState","options","setOptions","left","setLeft","top","setTop","selection","setSelection","matchStart","setMatchStart","matchEnd","setMatchEnd","inputRef","useRef","handleResize","handleSelection","index","currentString","newValue","setTimeout","elem","caretPos","range","setCaretPosition","target","reset","useEffect","window","style","position","className","e","caret","start","end","el","selectionEnd","document","len","normalizedValue","textInputRange","endRange","getInputSelection","input","getCaretCoordinates","indexOfLastSpace","currentWord","url","body","recover","result","then","fetch","res","data","found","console","getSuggestions","rect","Math","event","ref","width","classes","onMouseEnter","onClick","key","item","App","text","setText","setLang","map","l","placeholder","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.8f1565b4.chunk.js","sourcesContent":["export const languages = [\n  { label: \"Amharic\", value: \"am\" },\n  { label: \"Arabic\", value: \"ar\" },\n  { label: \"Bangla\", value: \"bn\" },\n  { label: \"Belarusian\", value: \"be\" },\n  { label: \"Bulgarian\", value: \"bg\" },\n  { label: \"Chinese (Hong Kong)\", value: \"yue-hant\" },\n  { label: \"Chinese (Simplified)\", value: \"zh\" },\n  { label: \"Chinese (Traditional)\", value: \"zh-hant\" },\n  { label: \"French\", value: \"fr\" },\n  { label: \"German\", value: \"de\" },\n  { label: \"Greek\", value: \"el\" },\n  { label: \"Gujarati\", value: \"gu\" },\n  { label: \"Hebrew\", value: \"he\" },\n  { label: \"Hindi\", value: \"hi\" },\n  { label: \"Italian\", value: \"it\" },\n  { label: \"Japanese\", value: \"ja\" },\n  { label: \"Kannada\", value: \"kn\" },\n  { label: \"Malayalam\", value: \"ml\" },\n  { label: \"Marathi\", value: \"mr\" },\n  { label: \"Nepali\", value: \"ne\" },\n  { label: \"Odia\", value: \"or\" },\n  { label: \"Persian\", value: \"fa\" },\n  { label: \"Portuguese (Brazil)\", value: \"pt\" },\n  { label: \"Punjabi\", value: \"pa\" },\n  { label: \"Russian\", value: \"ru\" },\n  { label: \"Sanskrit\", value: \"sa\" },\n  { label: \"Serbian\", value: \"sr\" },\n  { label: \"Sinhala\", value: \"si\" },\n  { label: \"Spanish\", value: \"es\" },\n  { label: \"Tamil\", value: \"ta\" },\n  { label: \"Telugu\", value: \"te\" },\n  { label: \"Tigrinya\", value: \"ti\" },\n  { label: \"Ukrainian\", value: \"uk\" },\n  { label: \"Urdu\", value: \"ur\" },\n  { label: \"Vietnamese\", value: \"vi\" },\n];\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React, { useEffect, useRef, useState } from \"react\";\nimport getInputSelection, { setCaretPosition } from \"./util\";\nimport getCaretCoordinates from \"textarea-caret\";\nimport classes from \"./styles.module.css\";\n\nconst KEY_UP = 38;\nconst KEY_DOWN = 40;\nconst KEY_RETURN = 13;\nconst KEY_ENTER = 14;\nconst KEY_ESCAPE = 27;\nconst KEY_TAB = 9;\n\nconst OPTION_LIST_Y_OFFSET = 10;\nconst OPTION_LIST_MIN_WIDTH = 100;\n\nexport const ReactTransliterate = ({\n  Component = \"input\",\n  onBlur = () => {},\n  disabled = false,\n  lang = \"hi\",\n  offsetX = 0,\n  offsetY = 10,\n  onChange,\n  value,\n  onKeyDown = () => {},\n  containerClassName = \"\",\n  containerStyles = {},\n  activeItemStyles = {},\n  maxOptions = 5,\n  ...rest\n}) => {\n  const [options, setOptions] = useState([]);\n  const [left, setLeft] = useState(0);\n  const [top, setTop] = useState(0);\n  const [selection, setSelection] = useState(0);\n  const [matchStart, setMatchStart] = useState(-1);\n  const [matchEnd, setMatchEnd] = useState(-1);\n  const inputRef = useRef(null);\n\n  const getSuggestions = async (lastWord) => {\n    // fetch suggestion from api\n    // const url = `https://www.google.com/inputtools/request?ime=transliteration_en_${lang}&num=5&cp=0&cs=0&ie=utf-8&oe=utf-8&app=jsapi&text=${lastWord}`;\n    const url = `https://inputtools.google.com/request?text=${lastWord}&itc=${lang}-t-i0-und&num=13&cp=0&cs=1&ie=utf-8&oe=utf-8&app=demopage`;\n    try {\n      const res = await fetch(url);\n      const data = await res.json();\n      if (data && data[0] === \"SUCCESS\") {\n        let found = data[1][0][1];\n        found = found.slice(0, maxOptions);\n        setOptions(found);\n      }\n    } catch (e) {\n      // catch error\n      console.error(\"There was an error with transliteration\", e);\n    }\n  };\n\n  const handleChange = (e) => {\n    const value = e.target.value;\n\n    // bubble up event to the parent component\n    onChange(e);\n\n    // get the current index of the cursor\n    const caret = getInputSelection(e.target).end;\n    const input = inputRef.current;\n    const caretPos = getCaretCoordinates(input, caret);\n\n    // search for the last occurence of the space character from\n    // the cursor\n    const indexOfLastSpace =\n      value.lastIndexOf(\" \", caret - 1) < value.lastIndexOf(\"\\n\", caret - 1)\n        ? value.lastIndexOf(\"\\n\", caret - 1)\n        : value.lastIndexOf(\" \", caret - 1);\n\n    // first character of the currently being typed word is\n    // one character after the space character\n    // index of last character is one before the current position\n    // of the caret\n    setMatchStart(indexOfLastSpace + 1);\n    setMatchEnd(caret - 1);\n\n    // currentWord is the word that is being typed\n    const currentWord = value.slice(indexOfLastSpace + 1, caret);\n    if (currentWord) {\n      // make an api call to fetch suggestions\n      getSuggestions(currentWord);\n\n      const rect = input.getBoundingClientRect();\n\n      // get the position of the top left corner of the suggestion box\n      // and save it to state\n      const top = caretPos.top + input.offsetTop;\n      const left = Math.min(\n        caretPos.left + input.offsetLeft - OPTION_LIST_Y_OFFSET,\n        input.offsetLeft + rect.width - OPTION_LIST_MIN_WIDTH,\n      );\n\n      setTop(top);\n      setLeft(left);\n    } else {\n      reset();\n    }\n  };\n\n  const handleKeyDown = (event) => {\n    const helperVisible = options.length > 0;\n\n    if (helperVisible) {\n      switch (event.keyCode) {\n        case KEY_ESCAPE:\n          event.preventDefault();\n          reset();\n          break;\n        case KEY_UP:\n          event.preventDefault();\n          setSelection((options.length + selection - 1) % options.length);\n          break;\n        case KEY_DOWN:\n          event.preventDefault();\n          setSelection((selection + 1) % options.length);\n          break;\n        case KEY_ENTER:\n        case KEY_RETURN:\n        case KEY_TAB:\n          event.preventDefault();\n          handleSelection(selection);\n          break;\n        default:\n          onKeyDown(event);\n          break;\n      }\n    } else {\n      onKeyDown(event);\n    }\n  };\n\n  const handleResize = () => {\n    // TODO implement the resize function to resize\n    // the helper on screen size change\n  };\n\n  const handleSelection = (index) => {\n    const currentString = value;\n    // create a new string with the currently typed word\n    // replaced with the word in transliterated language\n    const newValue =\n      currentString.substring(0, matchStart) +\n      options[index] +\n      \" \" +\n      currentString.substring(matchEnd + 1, currentString.length);\n\n    // set the position of the caret (cursor) one character after the\n    // the position of the new word\n    setTimeout(() => {\n      setCaretPosition(\n        inputRef.current,\n        matchStart + options[index].length + 1,\n      );\n    }, 1);\n\n    // bubble up event to the parent component\n    const e = { target: { value: newValue } };\n    onChange(e);\n    reset();\n  };\n\n  const reset = () => {\n    // reset the component\n    setSelection(0);\n    setOptions([]);\n  };\n\n  useEffect(() => {\n    window.addEventListener(\"resize\", handleResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, []);\n\n  return (\n    <div\n      // position relative is required to show the component\n      // in the correct position\n      style={{\n        ...containerStyles,\n        position: \"relative\",\n      }}\n      className={containerClassName}\n    >\n      <Component\n        disabled={disabled}\n        onBlur={onBlur}\n        onChange={handleChange}\n        onKeyDown={handleKeyDown}\n        ref={inputRef}\n        value={value}\n        {...rest}\n      />\n      {options.length > 0 && (\n        <ul\n          style={{\n            left: `${left + offsetX}px`,\n            top: `${top + offsetY}px`,\n            position: \"absolute\",\n            width: \"auto\",\n          }}\n          className={classes.ReactTransliterate}\n        >\n          {options.map((item, index) => (\n            <li\n              className={index === selection ? classes.Active : null}\n              style={index === selection ? activeItemStyles || {} : {}}\n              onMouseEnter={() => {\n                setSelection(index);\n              }}\n              onClick={() => handleSelection(index)}\n              key={item}\n            >\n              {item}\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n};\n","export default function (el) {\n  let start = 0;\n  let end = 0;\n\n  if (!el) {\n    return { start, end };\n  }\n\n  if (\n    typeof el.selectionStart === \"number\" &&\n    typeof el.selectionEnd === \"number\"\n  ) {\n    return { start: el.selectionStart, end: el.selectionEnd };\n  }\n\n  if (!document) {\n    return { start, end };\n  }\n\n  const range = document.selection.createRange();\n\n  if (!range && range.parentElement() !== el) {\n    return { start, end };\n  }\n\n  const len = el.value.length;\n  const normalizedValue = el.value.replace(/\\r\\n/g, \"\\n\");\n  const textInputRange = el.createTextRange();\n\n  textInputRange.moveToBookmark(range.getBookmark());\n\n  const endRange = el.createTextRange();\n\n  endRange.collapse(false);\n\n  if (textInputRange.compareEndPoints(\"StartToEnd\", endRange) > -1) {\n    start = end = len;\n  } else {\n    start = -textInputRange.moveStart(\"character\", -len);\n    start += normalizedValue.slice(0, start).split(\"\\n\").length - 1;\n\n    if (textInputRange.compareEndPoints(\"EndToEnd\", endRange) > -1) {\n      end = len;\n    } else {\n      end = -textInputRange.moveEnd(\"character\", -len);\n      end += normalizedValue.slice(0, end).split(\"\\n\").length - 1;\n    }\n  }\n\n  return { start, end };\n}\n\nexport function setCaretPosition(elem, caretPos) {\n  if (elem) {\n    if (elem.createTextRange) {\n      const range = elem.createTextRange();\n\n      range.move(\"character\", caretPos);\n      range.select();\n    } else {\n      if (elem.selectionStart) {\n        elem.focus();\n        elem.setSelectionRange(caretPos, caretPos);\n      } else {\n        elem.focus();\n      }\n    }\n  }\n}\n","import React, { useState } from \"react\";\n\n// language list for example only\nimport { languages } from \"./languages\";\n\n// import component\nimport { ReactTransliterate } from \"react-transliterate\";\nimport \"react-transliterate/dist/index.css\";\n\nconst App = () => {\n  const [text, setText] = useState(\"\");\n\n  const [lang, setLang] = useState(\"hi\");\n\n  return (\n    <div className=\"container\">\n      <h2>React transliterate</h2>\n\n      <select\n        className=\"language-dropdown\"\n        value={lang}\n        onChange={(e) => setLang(e.target.value)}\n      >\n        {languages.map((l) => (\n          <option key={l.value} value={l.value}>\n            {l.label}\n          </option>\n        ))}\n      </select>\n\n      <ReactTransliterate\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n        lang={lang}\n        placeholder=\"Start typing here...\"\n        containerStyles={{\n          width: \"300px\",\n        }}\n      />\n    </div>\n  );\n};\n\nexport default App;\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}